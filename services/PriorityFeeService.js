import axios from 'axios';

/**
 * PriorityFeeService - Handles multi-strategy priority fee computation
 * Supports multiple strategies: auto, fixed, dynamic, helius, statistical
 */
export class PriorityFeeService {
    constructor(networkService, options = {}) {
        this.networkService = networkService;
        this.cache = new Map();
        this.cacheTimeout = options.cacheTimeout || 30000; // 30 seconds
        
        // Configuration
        this.config = {
            // Base strategies
            strategies: {
                auto: { enabled: true, weight: 1.0 },
                fixed: { enabled: true, weight: 0.5 },
                dynamic: { enabled: true, weight: 1.5 },
                helius: { enabled: options.heliusApiKey ? true : false, weight: 2.0 },
                statistical: { enabled: true, weight: 1.2 }
            },
            
            // Limits and defaults
            minFee: options.minFee || 0,
            maxFee: options.maxFee || 50000, // 50k micro-lamports
            defaultFee: options.defaultFee || 5000,
            
            // Dynamic calculation parameters
            dynamicMultiplier: parseFloat(process.env.DYNAMIC_PRIORITY_FEE_MULTIPLIER) || options.dynamicMultiplier || 1.5,
            
            // Helius API
            heliusApiKey: options.heliusApiKey || process.env.HELIUS_API_KEY,
            heliusEndpoint: options.heliusEndpoint || 'https://mainnet.helius-rpc.com',
            
            // Statistical analysis
            sampleSize: options.sampleSize || 50,
            percentile: options.percentile || 75,
            
            // Network congestion thresholds
            congestionThresholds: {
                low: options.lowCongestion || 10,
                medium: options.mediumCongestion || 25,
                high: options.highCongestion || 50
            }
        };\n    }\n\n    /**\n     * Calculate priority fee using the specified strategy\n     * @param {string} strategy - Priority fee strategy\n     * @param {Object} options - Strategy-specific options\n     */\n    async calculatePriorityFee(strategy = 'auto', options = {}) {\n        const cacheKey = `fee_${strategy}_${JSON.stringify(options)}`;\n        \n        // Check cache first\n        if (this.cache.has(cacheKey)) {\n            const cached = this.cache.get(cacheKey);\n            if (Date.now() - cached.timestamp < this.cacheTimeout) {\n                console.log(`üìã Using cached priority fee: ${cached.value} ¬µLAM`);\n                return cached.value;\n            }\n        }\n\n        console.log(`‚ö° Calculating priority fee using ${strategy} strategy...`);\n        console.time('calculatePriorityFee');\n\n        let fee;\n        try {\n            switch (strategy.toLowerCase()) {\n                case 'auto':\n                    fee = await this.calculateAutoFee(options);\n                    break;\n                case 'fixed':\n                    fee = this.calculateFixedFee(options);\n                    break;\n                case 'dynamic':\n                    fee = await this.calculateDynamicFee(options);\n                    break;\n                case 'helius':\n                    fee = await this.calculateHeliusFee(options);\n                    break;\n                case 'statistical':\n                    fee = await this.calculateStatisticalFee(options);\n                    break;\n                case 'network_congestion':\n                    fee = await this.calculateNetworkCongestionFee(options);\n                    break;\n                case 'weighted_average':\n                    fee = await this.calculateWeightedAverageFee(options);\n                    break;\n                default:\n                    console.warn(`Unknown strategy: ${strategy}, falling back to auto`);\n                    fee = await this.calculateAutoFee(options);\n            }\n\n            // Apply limits\n            fee = this.applyLimits(fee, options);\n\n            // Cache the result\n            this.cache.set(cacheKey, {\n                value: fee,\n                timestamp: Date.now(),\n                strategy\n            });\n\n            console.timeEnd('calculatePriorityFee');\n            console.log(`‚úÖ Priority fee calculated: ${fee.toLocaleString()} ¬µLAM using ${strategy} strategy`);\n            \n            return fee;\n        } catch (error) {\n            console.timeEnd('calculatePriorityFee');\n            console.warn(`‚ö†Ô∏è  Failed to calculate priority fee with ${strategy}: ${error.message}`);\n            \n            // Fallback to default fee\n            const fallbackFee = this.config.defaultFee;\n            console.log(`üîÑ Using fallback fee: ${fallbackFee.toLocaleString()} ¬µLAM`);\n            return fallbackFee;\n        }\n    }\n\n    /**\n     * Auto strategy - intelligently selects the best approach\n     * @param {Object} options - Auto strategy options\n     */\n    async calculateAutoFee(options = {}) {\n        const strategies = [];\n        \n        // Try multiple strategies in parallel\n        const promises = [];\n        \n        if (this.config.strategies.statistical.enabled) {\n            promises.push(this.calculateStatisticalFee(options).catch(() => null));\n        }\n        \n        if (this.config.strategies.helius.enabled) {\n            promises.push(this.calculateHeliusFee(options).catch(() => null));\n        }\n        \n        if (this.config.strategies.dynamic.enabled) {\n            promises.push(this.calculateDynamicFee(options).catch(() => null));\n        }\n        \n        const results = await Promise.all(promises);\n        const validResults = results.filter(result => result !== null && result > 0);\n        \n        if (validResults.length === 0) {\n            return this.config.defaultFee;\n        }\n        \n        // Use median of valid results for stability\n        validResults.sort((a, b) => a - b);\n        const median = validResults[Math.floor(validResults.length / 2)];\n        \n        return median;\n    }\n\n    /**\n     * Fixed strategy - returns a predetermined fee\n     * @param {Object} options - Fixed fee options\n     */\n    calculateFixedFee(options = {}) {\n        const fixedFee = options.fixedFee || \n                         parseInt(process.env.FIXED_PRIORITY_FEE_MICRO_LAMPORTS) || \n                         this.config.defaultFee;\n        \n        return Math.max(0, parseInt(fixedFee));\n    }\n\n    /**\n     * Dynamic strategy - calculates based on recent network activity\n     * @param {Object} options - Dynamic fee options\n     */\n    async calculateDynamicFee(options = {}) {\n        const connection = this.networkService.getConnection();\n        const fees = await this.networkService.getRecentPrioritizationFees(options.accounts || []);\n        \n        if (!fees || fees.length === 0) {\n            return this.config.defaultFee;\n        }\n        \n        // Filter out zero fees and sort\n        const validFees = fees\n            .map(fee => fee.prioritizationFee)\n            .filter(fee => fee > 0)\n            .sort((a, b) => a - b);\n        \n        if (validFees.length === 0) {\n            return this.config.defaultFee;\n        }\n        \n        // Calculate various percentiles\n        const p50 = validFees[Math.floor(validFees.length * 0.5)];\n        const p75 = validFees[Math.floor(validFees.length * 0.75)];\n        const p90 = validFees[Math.floor(validFees.length * 0.9)];\n        \n        // Use 75th percentile as base, with dynamic multiplier\n        const baseFee = p75 || p50 || validFees[0];\n        const dynamicFee = Math.floor(baseFee * this.config.dynamicMultiplier);\n        \n        console.log(`üìä Dynamic fee analysis: P50=${p50}, P75=${p75}, P90=${p90}`);\n        \n        return dynamicFee;\n    }\n\n    /**\n     * Helius strategy - uses Helius priority fee API\n     * @param {Object} options - Helius fee options\n     */\n    async calculateHeliusFee(options = {}) {\n        if (!this.config.heliusApiKey) {\n            throw new Error('Helius API key not configured');\n        }\n        \n        const accounts = options.accounts || [];\n        const endpoint = `${this.config.heliusEndpoint}/?api-key=${this.config.heliusApiKey}`;\n        \n        try {\n            const response = await axios.post(endpoint, {\n                jsonrpc: '2.0',\n                id: 1,\n                method: 'getPriorityFeeEstimate',\n                params: [{\n                    accountKeys: accounts.map(acc => acc.toString()),\n                    options: {\n                        priority_level: options.priorityLevel || 'High'\n                    }\n                }]\n            }, {\n                timeout: 5000,\n                headers: {\n                    'Content-Type': 'application/json'\n                }\n            });\n            \n            if (response.data?.result?.priorityFeeEstimate) {\n                return Math.floor(response.data.result.priorityFeeEstimate);\n            }\n            \n            throw new Error('Invalid Helius response');\n        } catch (error) {\n            throw new Error(`Helius API error: ${error.message}`);\n        }\n    }\n\n    /**\n     * Statistical strategy - uses statistical analysis of recent fees\n     * @param {Object} options - Statistical analysis options\n     */\n    async calculateStatisticalFee(options = {}) {\n        const connection = this.networkService.getConnection();\n        const sampleSize = options.sampleSize || this.config.sampleSize;\n        const percentile = options.percentile || this.config.percentile;\n        \n        // Get recent prioritization fees\n        const fees = await this.networkService.getRecentPrioritizationFees(options.accounts || []);\n        \n        if (!fees || fees.length === 0) {\n            return this.config.defaultFee;\n        }\n        \n        // Extract and filter fees\n        const validFees = fees\n            .map(fee => fee.prioritizationFee)\n            .filter(fee => fee > 0)\n            .slice(-sampleSize) // Take most recent samples\n            .sort((a, b) => a - b);\n        \n        if (validFees.length === 0) {\n            return this.config.defaultFee;\n        }\n        \n        // Calculate statistics\n        const mean = validFees.reduce((sum, fee) => sum + fee, 0) / validFees.length;\n        const median = validFees[Math.floor(validFees.length / 2)];\n        const targetPercentile = validFees[Math.floor(validFees.length * (percentile / 100))];\n        \n        // Calculate standard deviation\n        const variance = validFees.reduce((sum, fee) => sum + Math.pow(fee - mean, 2), 0) / validFees.length;\n        const stdDev = Math.sqrt(variance);\n        \n        // Use percentile with volatility adjustment\n        let statisticalFee = targetPercentile;\n        \n        // If high volatility, add buffer\n        const volatilityRatio = stdDev / mean;\n        if (volatilityRatio > 0.5) { // High volatility\n            statisticalFee = Math.floor(statisticalFee * 1.2);\n        }\n        \n        console.log(`üìà Statistical analysis: Mean=${Math.floor(mean)}, Median=${median}, P${percentile}=${targetPercentile}, StdDev=${Math.floor(stdDev)}`);\n        \n        return statisticalFee;\n    }\n\n    /**\n     * Network congestion strategy - adjusts fee based on network congestion\n     * @param {Object} options - Network congestion options\n     */\n    async calculateNetworkCongestionFee(options = {}) {\n        const connection = this.networkService.getConnection();\n        \n        try {\n            // Get network metrics\n            const [recentBlockhash, slot] = await Promise.all([\n                connection.getLatestBlockhash(),\n                connection.getSlot()\n            ]);\n            \n            // Estimate congestion based on available metrics\n            // This is a simplified approach - in practice, you might use more sophisticated metrics\n            const fees = await this.networkService.getRecentPrioritizationFees();\n            const avgFee = fees.length > 0 \n                ? fees.reduce((sum, fee) => sum + fee.prioritizationFee, 0) / fees.length\n                : 0;\n            \n            let congestionLevel = 'low';\n            let multiplier = 1.0;\n            \n            if (avgFee > this.config.congestionThresholds.high) {\n                congestionLevel = 'high';\n                multiplier = 2.0;\n            } else if (avgFee > this.config.congestionThresholds.medium) {\n                congestionLevel = 'medium';\n                multiplier = 1.5;\n            } else if (avgFee > this.config.congestionThresholds.low) {\n                congestionLevel = 'low';\n                multiplier = 1.2;\n            }\n            \n            const baseFee = this.config.defaultFee;\n            const congestionFee = Math.floor(baseFee * multiplier);\n            \n            console.log(`üö¶ Network congestion: ${congestionLevel} (avg fee: ${Math.floor(avgFee)} ¬µLAM)`);\n            \n            return congestionFee;\n        } catch (error) {\n            throw new Error(`Network congestion analysis failed: ${error.message}`);\n        }\n    }\n\n    /**\n     * Weighted average strategy - combines multiple strategies with weights\n     * @param {Object} options - Weighted average options\n     */\n    async calculateWeightedAverageFee(options = {}) {\n        const strategies = options.strategies || this.config.strategies;\n        const results = [];\n        \n        // Collect results from enabled strategies\n        for (const [strategyName, config] of Object.entries(strategies)) {\n            if (!config.enabled) continue;\n            \n            try {\n                let fee;\n                switch (strategyName) {\n                    case 'fixed':\n                        fee = this.calculateFixedFee(options);\n                        break;\n                    case 'dynamic':\n                        fee = await this.calculateDynamicFee(options);\n                        break;\n                    case 'helius':\n                        fee = await this.calculateHeliusFee(options);\n                        break;\n                    case 'statistical':\n                        fee = await this.calculateStatisticalFee(options);\n                        break;\n                    default:\n                        continue;\n                }\n                \n                results.push({\n                    strategy: strategyName,\n                    fee: fee,\n                    weight: config.weight\n                });\n            } catch (error) {\n                console.warn(`‚ö†Ô∏è  Strategy ${strategyName} failed: ${error.message}`);\n            }\n        }\n        \n        if (results.length === 0) {\n            return this.config.defaultFee;\n        }\n        \n        // Calculate weighted average\n        const totalWeight = results.reduce((sum, result) => sum + result.weight, 0);\n        const weightedSum = results.reduce((sum, result) => sum + (result.fee * result.weight), 0);\n        const weightedAverage = Math.floor(weightedSum / totalWeight);\n        \n        console.log(`‚öñÔ∏è  Weighted average from ${results.length} strategies: ${weightedAverage} ¬µLAM`);\n        \n        return weightedAverage;\n    }\n\n    /**\n     * Apply min/max limits and validation to calculated fee\n     * @param {number} fee - Calculated fee\n     * @param {Object} options - Options with potential overrides\n     */\n    applyLimits(fee, options = {}) {\n        const minFee = options.minFee ?? this.config.minFee;\n        const maxFee = options.maxFee ?? parseInt(process.env.MAX_PRIORITY_FEE_MICRO_LAMPORTS) ?? this.config.maxFee;\n        \n        // Ensure fee is a valid number\n        if (isNaN(fee) || fee < 0) {\n            fee = this.config.defaultFee;\n        }\n        \n        // Apply limits\n        fee = Math.max(minFee, Math.min(maxFee, fee));\n        \n        return Math.floor(fee);\n    }\n\n    /**\n     * Get fee recommendation based on transaction urgency\n     * @param {string} urgency - Transaction urgency level: 'low', 'normal', 'high', 'critical'\n     * @param {Object} options - Additional options\n     */\n    async getRecommendedFee(urgency = 'normal', options = {}) {\n        const urgencyMultipliers = {\n            low: 0.8,\n            normal: 1.0,\n            high: 1.5,\n            critical: 2.0\n        };\n        \n        const multiplier = urgencyMultipliers[urgency] || 1.0;\n        const baseFee = await this.calculatePriorityFee('auto', options);\n        const recommendedFee = Math.floor(baseFee * multiplier);\n        \n        console.log(`üéØ Recommended fee for ${urgency} urgency: ${recommendedFee.toLocaleString()} ¬µLAM`);\n        \n        return this.applyLimits(recommendedFee, options);\n    }\n\n    /**\n     * Get priority fee analysis and recommendations\n     * @param {Object} options - Analysis options\n     */\n    async analyzePriorityFees(options = {}) {\n        console.log('üìä Analyzing priority fee landscape...');\n        \n        const analysis = {\n            timestamp: Date.now(),\n            strategies: {},\n            recommendations: {},\n            network: {}\n        };\n        \n        // Run multiple strategies\n        const strategies = ['fixed', 'dynamic', 'statistical'];\n        if (this.config.heliusApiKey) strategies.push('helius');\n        \n        for (const strategy of strategies) {\n            try {\n                const fee = await this.calculatePriorityFee(strategy, options);\n                analysis.strategies[strategy] = {\n                    fee,\n                    enabled: true\n                };\n            } catch (error) {\n                analysis.strategies[strategy] = {\n                    fee: null,\n                    enabled: false,\n                    error: error.message\n                };\n            }\n        }\n        \n        // Generate recommendations for different urgency levels\n        for (const urgency of ['low', 'normal', 'high', 'critical']) {\n            try {\n                analysis.recommendations[urgency] = await this.getRecommendedFee(urgency, options);\n            } catch (error) {\n                analysis.recommendations[urgency] = null;\n            }\n        }\n        \n        // Network congestion info\n        try {\n            const fees = await this.networkService.getRecentPrioritizationFees();\n            if (fees.length > 0) {\n                const validFees = fees.map(f => f.prioritizationFee).filter(f => f > 0);\n                analysis.network = {\n                    sampleSize: validFees.length,\n                    min: Math.min(...validFees),\n                    max: Math.max(...validFees),\n                    avg: Math.floor(validFees.reduce((a, b) => a + b, 0) / validFees.length)\n                };\n            }\n        } catch (error) {\n            analysis.network.error = error.message;\n        }\n        \n        return analysis;\n    }\n\n    /**\n     * Clear expired cache entries\n     */\n    clearExpiredCache() {\n        const now = Date.now();\n        for (const [key, value] of this.cache.entries()) {\n            if (now - value.timestamp > this.cacheTimeout) {\n                this.cache.delete(key);\n            }\n        }\n    }\n\n    /**\n     * Update strategy configuration\n     * @param {Object} newConfig - New configuration\n     */\n    updateConfig(newConfig) {\n        this.config = { ...this.config, ...newConfig };\n        this.cache.clear(); // Clear cache when config changes\n    }\n\n    /**\n     * Get current configuration\n     */\n    getConfig() {\n        return { ...this.config };\n    }\n\n    /**\n     * Cleanup resources\n     */\n    destroy() {\n        this.cache.clear();\n    }\n}\n\nexport default PriorityFeeService;
