import { 
    VersionedTransaction, 
    TransactionMessage, 
    ComputeBudgetProgram 
} from '@solana/web3.js';

/**
 * TxService - Handles transaction building, simulation, sending, and compute unit optimization
 * Responsible for all transaction-related operations with optimization and error handling
 */
export class TxService {
    constructor(networkService, options = {}) {\n        this.networkService = networkService;\n        this.options = {\n            maxRetries: options.maxRetries || 3,\n            retryDelay: options.retryDelay || 1000,\n            simulationTimeout: options.simulationTimeout || 15000,\n            confirmationTimeout: options.confirmationTimeout || 60000,\n            skipPreflight: options.skipPreflight || false,\n            preflightCommitment: options.preflightCommitment || 'confirmed',\n            maxComputeUnits: options.maxComputeUnits || 1400000, // 1.4M CU limit\n            computeUnitBuffer: options.computeUnitBuffer || 0.1, // 10% buffer\n            ...options\n        };\n        \n        // Transaction metrics tracking\n        this.metrics = {\n            transactionsSent: 0,\n            transactionsConfirmed: 0,\n            transactionsFailed: 0,\n            averageComputeUnits: 0,\n            averageConfirmationTime: 0\n        };\n    }\n\n    /**\n     * Deserialize and prepare transaction for processing\n     * @param {string} serializedTransaction - Base64 encoded transaction\n     * @param {Keypair} signerKeypair - Keypair for signing\n     */\n    async prepareTransaction(serializedTransaction, signerKeypair) {\n        console.log('🔄 Preparing transaction...');\n        \n        try {\n            // Deserialize the transaction\n            const transactionBuf = Buffer.from(serializedTransaction, 'base64');\n            let transaction = VersionedTransaction.deserialize(transactionBuf);\n            \n            // Validate transaction structure\n            this.validateTransaction(transaction);\n            \n            // Sign the transaction\n            transaction.sign([signerKeypair]);\n            \n            return transaction;\n        } catch (error) {\n            throw new Error(`Failed to prepare transaction: ${error.message}`);\n        }\n    }\n\n    /**\n     * Validate transaction structure and properties\n     * @param {VersionedTransaction} transaction - Transaction to validate\n     */\n    validateTransaction(transaction) {\n        if (!transaction) {\n            throw new Error('Transaction is null or undefined');\n        }\n        \n        if (!transaction.message) {\n            throw new Error('Transaction message is missing');\n        }\n        \n        const message = transaction.message;\n        \n        // Check for reasonable number of instructions\n        if (message.compiledInstructions.length === 0) {\n            throw new Error('Transaction has no instructions');\n        }\n        \n        if (message.compiledInstructions.length > 10) {\n            console.warn(`⚠️  Transaction has ${message.compiledInstructions.length} instructions - this may be complex`);\n        }\n        \n        // Check for reasonable number of accounts\n        if (message.staticAccountKeys.length > 32) {\n            console.warn(`⚠️  Transaction references ${message.staticAccountKeys.length} accounts`);\n        }\n    }\n\n    /**\n     * Simulate transaction with detailed analysis\n     * @param {VersionedTransaction} transaction - Transaction to simulate\n     * @param {Object} options - Simulation options\n     */\n    async simulateTransaction(transaction, options = {}) {\n        console.log('🧪 Simulating transaction...');\n        console.time('simulateTransaction');\n        \n        const simulationOptions = {\n            replaceRecentBlockhash: options.replaceRecentBlockhash ?? true,\n            sigVerify: options.sigVerify ?? false,\n            commitment: options.commitment || 'confirmed',\n            ...options.simulationOptions\n        };\n        \n        try {\n            const simulationResult = await this.networkService.simulateTransaction(\n                transaction, \n                simulationOptions\n            );\n            \n            console.timeEnd('simulateTransaction');\n            \n            // Analyze simulation result\n            const analysis = this.analyzeSimulationResult(simulationResult);\n            \n            // Log simulation details\n            this.logSimulationDetails(analysis);\n            \n            return {\n                result: simulationResult,\n                analysis,\n                success: !simulationResult.value.err\n            };\n            \n        } catch (error) {\n            console.timeEnd('simulateTransaction');\n            \n            if (error.simulationResult) {\n                // Enhanced error with simulation context\n                const analysis = this.analyzeSimulationResult({ value: error.simulationResult });\n                \n                console.error('❌ Simulation failed with details:');\n                this.logSimulationDetails(analysis);\n                \n                const enhancedError = new Error(`Transaction simulation failed: ${this.formatSimulationError(error.simulationResult.err)}`);\n                enhancedError.simulationResult = error.simulationResult;\n                enhancedError.analysis = analysis;\n                throw enhancedError;\n            }\n            \n            throw new Error(`Transaction simulation failed: ${error.message}`);\n        }\n    }\n\n    /**\n     * Analyze simulation result for insights and optimization\n     * @param {Object} simulationResult - Result from transaction simulation\n     */\n    analyzeSimulationResult(simulationResult) {\n        const { value } = simulationResult;\n        \n        const analysis = {\n            success: !value.err,\n            computeUnitsConsumed: value.unitsConsumed || 0,\n            logs: value.logs || [],\n            error: value.err,\n            accounts: value.accounts || [],\n            returnData: value.returnData,\n            innerInstructions: value.innerInstructions || []\n        };\n        \n        // Compute unit analysis\n        if (analysis.computeUnitsConsumed > 0) {\n            analysis.computeEfficiency = {\n                used: analysis.computeUnitsConsumed,\n                percentage: (analysis.computeUnitsConsumed / this.options.maxComputeUnits) * 100,\n                recommendedLimit: Math.ceil(analysis.computeUnitsConsumed * (1 + this.options.computeUnitBuffer)),\n                isEfficient: analysis.computeUnitsConsumed < (this.options.maxComputeUnits * 0.8)\n            };\n        }\n        \n        // Log analysis\n        if (analysis.logs.length > 0) {\n            analysis.programLogs = this.extractProgramLogs(analysis.logs);\n            analysis.errorLogs = this.extractErrorLogs(analysis.logs);\n            analysis.warningLogs = this.extractWarningLogs(analysis.logs);\n        }\n        \n        // Success metrics\n        if (analysis.success) {\n            analysis.successMetrics = {\n                instructionsExecuted: analysis.innerInstructions.length + 1,\n                accountsModified: analysis.accounts.filter(acc => acc?.data).length\n            };\n        }\n        \n        return analysis;\n    }\n\n    /**\n     * Extract program-specific logs from simulation logs\n     * @param {Array} logs - Simulation logs\n     */\n    extractProgramLogs(logs) {\n        return logs.filter(log => \n            log.includes('Program') && \n            (log.includes('invoke') || log.includes('success') || log.includes('consumed'))\n        );\n    }\n\n    /**\n     * Extract error logs from simulation logs\n     * @param {Array} logs - Simulation logs\n     */\n    extractErrorLogs(logs) {\n        return logs.filter(log => \n            log.toLowerCase().includes('error') ||\n            log.toLowerCase().includes('failed') ||\n            log.toLowerCase().includes('revert')\n        );\n    }\n\n    /**\n     * Extract warning logs from simulation logs\n     * @param {Array} logs - Simulation logs\n     */\n    extractWarningLogs(logs) {\n        return logs.filter(log => \n            log.toLowerCase().includes('warning') ||\n            log.toLowerCase().includes('deprecated')\n        );\n    }\n\n    /**\n     * Send transaction with enhanced retry logic and monitoring\n     * @param {VersionedTransaction} transaction - Transaction to send\n     * @param {Object} options - Send options\n     */\n    async sendTransaction(transaction, options = {}) {\n        console.log('📨 Sending transaction...');\n        console.time('sendTransaction');\n        \n        const sendOptions = {\n            skipPreflight: options.skipPreflight ?? this.options.skipPreflight,\n            preflightCommitment: options.preflightCommitment || this.options.preflightCommitment,\n            maxRetries: options.maxRetries || this.options.maxRetries,\n            retryDelay: options.retryDelay || this.options.retryDelay\n        };\n        \n        let signature;\n        let lastError;\n        \n        for (let attempt = 0; attempt < sendOptions.maxRetries; attempt++) {\n            try {\n                signature = await this.networkService.sendTransaction(transaction, {\n                    skipPreflight: sendOptions.skipPreflight,\n                    preflightCommitment: sendOptions.preflightCommitment,\n                    maxRetries: 1 // Handle retries at this level\n                });\n                \n                this.metrics.transactionsSent++;\n                break;\n                \n            } catch (error) {\n                lastError = error;\n                \n                // Analyze the error to determine if retry is worthwhile\n                const shouldRetry = this.shouldRetryTransaction(error, attempt);\n                \n                if (!shouldRetry || attempt === sendOptions.maxRetries - 1) {\n                    break;\n                }\n                \n                console.log(`⚠️  Send attempt ${attempt + 1}/${sendOptions.maxRetries} failed: ${error.message}`);\n                console.log(`🔄 Retrying in ${sendOptions.retryDelay}ms...`);\n                \n                await new Promise(resolve => setTimeout(resolve, sendOptions.retryDelay));\n            }\n        }\n        \n        if (!signature) {\n            console.timeEnd('sendTransaction');\n            this.metrics.transactionsFailed++;\n            throw new Error(`Failed to send transaction after ${sendOptions.maxRetries} attempts: ${lastError?.message || 'Unknown error'}`);\n        }\n        \n        console.timeEnd('sendTransaction');\n        console.log(`✅ Transaction sent successfully: ${signature}`);\n        \n        return signature;\n    }\n\n    /**\n     * Determine if a transaction should be retried based on the error\n     * @param {Error} error - The error that occurred\n     * @param {number} attempt - Current attempt number\n     */\n    shouldRetryTransaction(error, attempt) {\n        const errorMessage = error.message.toLowerCase();\n        \n        // Don't retry on fundamental errors\n        const nonRetryableErrors = [\n            'insufficient funds',\n            'invalid signature',\n            'account not found',\n            'blockhash not found',\n            'transaction too large'\n        ];\n        \n        if (nonRetryableErrors.some(nonRetryable => errorMessage.includes(nonRetryable))) {\n            return false;\n        }\n        \n        // Retry on network-related errors\n        const retryableErrors = [\n            'timeout',\n            'network error',\n            'connection',\n            'rate limit',\n            'server error',\n            '500',\n            '502',\n            '503',\n            '504'\n        ];\n        \n        return retryableErrors.some(retryable => errorMessage.includes(retryable));\n    }\n\n    /**\n     * Confirm transaction with timeout and detailed status\n     * @param {string} signature - Transaction signature\n     * @param {Object} options - Confirmation options\n     */\n    async confirmTransaction(signature, options = {}) {\n        console.log('⏳ Confirming transaction...');\n        console.time('confirmTransaction');\n        \n        const confirmOptions = {\n            commitment: options.commitment || 'confirmed',\n            timeout: options.timeout || this.options.confirmationTimeout\n        };\n        \n        try {\n            const startTime = Date.now();\n            \n            const confirmation = await this.networkService.confirmTransaction(\n                signature,\n                confirmOptions.commitment,\n                confirmOptions.timeout\n            );\n            \n            const confirmationTime = Date.now() - startTime;\n            \n            // Update metrics\n            this.metrics.transactionsConfirmed++;\n            this.metrics.averageConfirmationTime = \n                (this.metrics.averageConfirmationTime + confirmationTime) / 2;\n            \n            console.timeEnd('confirmTransaction');\n            console.log(`✅ Transaction confirmed in ${confirmationTime}ms`);\n            \n            return {\n                confirmation,\n                confirmationTime,\n                signature\n            };\n            \n        } catch (error) {\n            console.timeEnd('confirmTransaction');\n            \n            if (error.confirmationResult) {\n                const enhancedError = new Error(`Transaction confirmation failed: ${this.formatConfirmationError(error.confirmationResult.err)}`);\n                enhancedError.confirmationResult = error.confirmationResult;\n                enhancedError.signature = signature;\n                throw enhancedError;\n            }\n            \n            throw new Error(`Transaction confirmation failed: ${error.message}`);\n        }\n    }\n\n    /**\n     * Execute complete transaction workflow: send + confirm\n     * @param {VersionedTransaction} transaction - Transaction to execute\n     * @param {Object} options - Execution options\n     */\n    async executeTransaction(transaction, options = {}) {\n        console.log('🚀 Executing transaction workflow...');\n        console.time('executeTransaction');\n        \n        try {\n            // Optional simulation before sending\n            if (options.simulate !== false) {\n                const simulation = await this.simulateTransaction(transaction, options.simulation);\n                if (!simulation.success && options.failOnSimulationError !== false) {\n                    throw new Error(`Pre-execution simulation failed: ${JSON.stringify(simulation.result.value.err)}`);\n                }\n            }\n            \n            // Send transaction\n            const signature = await this.sendTransaction(transaction, options.send);\n            \n            // Confirm transaction\n            const confirmationResult = await this.confirmTransaction(signature, options.confirmation);\n            \n            console.timeEnd('executeTransaction');\n            \n            return {\n                signature,\n                confirmation: confirmationResult.confirmation,\n                confirmationTime: confirmationResult.confirmationTime,\n                success: true\n            };\n            \n        } catch (error) {\n            console.timeEnd('executeTransaction');\n            throw error;\n        }\n    }\n\n    /**\n     * Optimize compute unit limit based on simulation results\n     * @param {string} serializedTransaction - Transaction to optimize\n     * @param {Keypair} signerKeypair - Signing keypair\n     * @param {Object} options - Optimization options\n     */\n    async optimizeComputeUnits(serializedTransaction, signerKeypair, options = {}) {\n        console.log('⚙️ Optimizing compute units...');\n        \n        try {\n            // Prepare transaction\n            const transaction = await this.prepareTransaction(serializedTransaction, signerKeypair);\n            \n            // Simulate to get actual usage\n            const simulation = await this.simulateTransaction(transaction, {\n                replaceRecentBlockhash: true,\n                sigVerify: false\n            });\n            \n            if (!simulation.success) {\n                console.warn('⚠️  Cannot optimize CU - simulation failed');\n                return { optimized: false, reason: 'Simulation failed' };\n            }\n            \n            const { computeEfficiency } = simulation.analysis;\n            if (!computeEfficiency) {\n                console.warn('⚠️  Cannot optimize CU - no compute usage data');\n                return { optimized: false, reason: 'No compute data' };\n            }\n            \n            const currentUsage = computeEfficiency.used;\n            const recommendedLimit = computeEfficiency.recommendedLimit;\n            \n            // Check if optimization is beneficial\n            if (computeEfficiency.isEfficient) {\n                console.log(`✅ Transaction is already efficient (${currentUsage} CU, ${computeEfficiency.percentage.toFixed(1)}%)`);\n                return {\n                    optimized: false,\n                    reason: 'Already efficient',\n                    currentUsage,\n                    efficiency: computeEfficiency\n                };\n            }\n            \n            // Apply compute unit optimization (this would need to be implemented based on your transaction structure)\n            console.log(`🎯 Recommending compute limit: ${recommendedLimit} CU (currently using ${currentUsage} CU)`);\n            \n            return {\n                optimized: true,\n                originalUsage: currentUsage,\n                recommendedLimit,\n                efficiency: computeEfficiency,\n                savings: this.options.maxComputeUnits - recommendedLimit\n            };\n            \n        } catch (error) {\n            console.warn(`⚠️  Compute unit optimization failed: ${error.message}`);\n            return { optimized: false, reason: error.message };\n        }\n    }\n\n    /**\n     * Format simulation error for better readability\n     * @param {Object} error - Simulation error object\n     */\n    formatSimulationError(error) {\n        if (!error) return 'Unknown error';\n        \n        if (typeof error === 'string') return error;\n        \n        if (error.InstructionError) {\n            const [index, err] = error.InstructionError;\n            return `Instruction ${index} failed: ${this.formatSimulationError(err)}`;\n        }\n        \n        if (error.Custom) {\n            return `Custom error: ${error.Custom}`;\n        }\n        \n        // Convert object to readable format\n        return JSON.stringify(error);\n    }\n\n    /**\n     * Format confirmation error for better readability\n     * @param {Object} error - Confirmation error object\n     */\n    formatConfirmationError(error) {\n        return this.formatSimulationError(error); // Same format for now\n    }\n\n    /**\n     * Log detailed simulation information\n     * @param {Object} analysis - Simulation analysis results\n     */\n    logSimulationDetails(analysis) {\n        if (analysis.success) {\n            console.log('✅ Simulation successful');\n        } else {\n            console.log('❌ Simulation failed');\n        }\n        \n        if (analysis.computeEfficiency) {\n            const { used, percentage, recommendedLimit, isEfficient } = analysis.computeEfficiency;\n            console.log(`   💻 Compute Units: ${used.toLocaleString()} (${percentage.toFixed(1)}% of max)`);\n            console.log(`   🎯 Recommended Limit: ${recommendedLimit.toLocaleString()} CU`);\n            console.log(`   ⚡ Efficient: ${isEfficient ? 'Yes' : 'No'}`);\n        }\n        \n        if (analysis.programLogs.length > 0) {\n            console.log(`   📋 Program Logs (${analysis.programLogs.length}):`);\n            analysis.programLogs.slice(-3).forEach(log => console.log(`      ${log}`));\n        }\n        \n        if (analysis.errorLogs.length > 0) {\n            console.log(`   ❌ Error Logs (${analysis.errorLogs.length}):`);\n            analysis.errorLogs.forEach(log => console.log(`      ${log}`));\n        }\n        \n        if (analysis.warningLogs.length > 0) {\n            console.log(`   ⚠️  Warning Logs (${analysis.warningLogs.length}):`);\n            analysis.warningLogs.forEach(log => console.log(`      ${log}`));\n        }\n    }\n\n    /**\n     * Get transaction service metrics\n     */\n    getMetrics() {\n        return {\n            ...this.metrics,\n            successRate: this.metrics.transactionsSent > 0 \n                ? (this.metrics.transactionsConfirmed / this.metrics.transactionsSent) * 100 \n                : 0\n        };\n    }\n\n    /**\n     * Reset metrics counters\n     */\n    resetMetrics() {\n        this.metrics = {\n            transactionsSent: 0,\n            transactionsConfirmed: 0,\n            transactionsFailed: 0,\n            averageComputeUnits: 0,\n            averageConfirmationTime: 0\n        };\n    }\n\n    /**\n     * Update service configuration\n     * @param {Object} newOptions - New options to merge\n     */\n    updateOptions(newOptions) {\n        this.options = { ...this.options, ...newOptions };\n    }\n\n    /**\n     * Get current service configuration\n     */\n    getOptions() {\n        return { ...this.options };\n    }\n\n    /**\n     * Cleanup resources\n     */\n    destroy() {\n        // No specific cleanup needed for this service\n        console.log('🧹 TxService destroyed');\n    }\n}\n\nexport default TxService;
